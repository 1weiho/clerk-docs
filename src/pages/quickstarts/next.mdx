import { Tab, Tabs } from "nextra-theme-docs";
import { Callout } from "nextra-theme-docs";
import {YouTube} from "@/components/Youtube"

# Use Clerk with Next.js

Learn how to use Clerk with Next.js including protecting pages.

<Callout type="info" emoji="ℹ️">
Are you looking to use Next.js App Layout Beta? Check out our Next.js App Beta guide.
</Callout>

## Install @clerk/nextjs

Once you have a Next.js application ready, you need to install Clerk's Next.js SDK. This gives you access to our prebuilt components and hooks for React, as well as our helpers for Next.js API routes, server-side rendering, and edge middleware.

<Tabs items={['npm', 'yarn', 'pnpm']}>
<Tab>
```
npm install @clerk/nextjs
```
</Tab>
<Tab>
```
yarn add @clerk/nextjs
```
</Tab>
<Tab>
```
pnpm i @clerk/nextjs
```
</Tab>
</Tabs>

## Set Environment Keys

Below is an example of your .env.local file. To get the respective keys go to the API Keys page in the Clerk dashboard.

```sh copy filename=".env.local"
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_••••••••••••••••••••••••••••••••••
CLERK_SECRET_KEY=sk_test_••••••••••••••••••••••••••••••••••
```

## Configure `<ClerkProvider>`

Clerk requires your Next.js application to be wrapped in the `<ClerkProvider/>` component. The `<ClerkProvider />` component wraps your Next.js application to provide active session and user context to Clerk's hooks and other components.

<Tabs items={['_app,tsx', '_app.js']}>
<Tab>
```tsx copy
import { ClerkProvider } from '@clerk/nextjs';
import type { AppProps } from 'next/app'

function MyApp({ Component, pageProps }: AppProps) {
return (

<ClerkProvider {...pageProps}>
  <Component {...pageProps} />
</ClerkProvider>
); }

export default MyApp;
```
</Tab>
<Tab>
```jsx copy
import { ClerkProvider } from '@clerk/nextjs';

function MyApp({ Component, pageProps }) {
return (

<ClerkProvider {...pageProps}>
  <Component {...pageProps} />
</ClerkProvider>
); }

export default MyApp;
```
</Tab>
</Tabs>

## Protecting Your Pages

Clerk offers two ways to protect your Next.js application, you can use Next.js Middleware or use control components.

<Tabs items={['Middleware Protection', 'Control Components']}>
<Tab>
Using Middleware is the most comprehensive way to implement page protection in your app. Below is an example of page protection using Middleware.

<Tabs items={['middleware.ts', 'middleware.js']}>
<Tab>
```tsx
import { withClerkMiddleware, getAuth } from '@clerk/nextjs/server'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

// Set the paths that don't require the user to be signed in
const publicPaths = ['/', '/sign-in*', '/sign-up*']

const isPublic = (path: string) => {
return publicPaths.find(x =>
path.match(new RegExp(`^${x}$`.replace('\*$', '($|/)')))
)
}

export default withClerkMiddleware((request: NextRequest) => {
  if (isPublic(request.nextUrl.pathname)) {
    return NextResponse.next()
  }
  // if the user is not signed in redirect them to the sign in page.
  const { userId } = getAuth(request)

if (!userId) {
// redirect the users to /pages/sign-in/[[...index]].ts

    const signInUrl = new URL('/sign-in', request.url)
    signInUrl.searchParams.set('redirect_url', request.url)
    return NextResponse.redirect(signInUrl)

}
return NextResponse.next()
})

export const config = { matcher: '/((?!.*\\.).*)' }
```
</Tab>
<Tab>
```jsx
import { withClerkMiddleware, getAuth } from '@clerk/nextjs/server'
import { NextResponse } from 'next/server'

// Set the paths that don't require the user to be signed in
const publicPaths = ['/', '/sign-in*', '/sign-up*']

const isPublic = () => {
return publicPaths.find(x =>
path.match(new RegExp(`^${x}$`.replace('\*$', '($|/)')))
)
}

export default withClerkMiddleware(() => {
  if (isPublic(request.nextUrl.pathname)) {
    return NextResponse.next()
  }
  // if the user is not signed in redirect them to the sign in page.
  const { userId } = getAuth(request)

if (!userId) {
// redirect the users to /pages/sign-in/[[...index]].ts

    const signInUrl = new URL('/sign-in', request.url)
    signInUrl.searchParams.set('redirect_url', request.url)
    return NextResponse.redirect(signInUrl)

}
return NextResponse.next()
})

export const config = { matcher: '/((?!.*\\.).*)' }
```
</Tab>
</Tabs>
</Tab>
<Tab>
If you prefer to use Clerk's Control Components for page protection, the following example shows you how to compose control components.
<Tabs items={['_app.tsx', 'app.js']}>

<Tab>

```tsx
import {
  ClerkProvider,
  SignedIn,
  SignedOut,
  RedirectToSignIn,
} from "@clerk/nextjs";
import { AppProps } from "next/app";
import { useRouter } from "next/router";

//  List pages you want to be publicly accessible, or leave empty if
//  every page requires authentication. Use this naming strategy:
//   "/"              for pages/index.js
//   "/foo"           for pages/foo/index.js
//   "/foo/bar"       for pages/foo/bar.js
//   "/foo/[...bar]"  for pages/foo/[...bar].js
const publicPages: Array<string> = [];

function MyApp({ Component, pageProps }: AppProps) {
  // Get the pathname
  const { pathname } = useRouter();

  // Check if the current route matches a public page
  const isPublicPage = publicPages.includes(pathname);

  // If the current route is listed as public, render it directly
  // Otherwise, use Clerk to require authentication
  return (
    <ClerkProvider {...pageProps}>
      {isPublicPage ? (
        <Component {...pageProps} />
      ) : (
        <>
          <SignedIn>
            <Component {...pageProps} />
          </SignedIn>
          <SignedOut>
            <RedirectToSignIn />
          </SignedOut>
        </>
      )}
    </ClerkProvider>
  );
}

export default MyApp;
```

</Tab>
<Tab>

```jsx
import {
  ClerkProvider,
  SignedIn,
  SignedOut,
  RedirectToSignIn,
} from "@clerk/nextjs";
import { useRouter } from "next/router";

//  List pages you want to be publicly accessible, or leave empty if
//  every page requires authentication. Use this naming strategy:
//   "/"              for pages/index.js
//   "/foo"           for pages/foo/index.js
//   "/foo/bar"       for pages/foo/bar.js
//   "/foo/[...bar]"  for pages/foo/[...bar].js
const publicPages = [];

function MyApp({ Component, pageProps }) {
  // Get the pathname
  const { pathname } = useRouter();

  // Check if the current route matches a public page
  const isPublicPage = publicPages.includes(pathname);

  // If the current route is listed as public, render it directly
  // Otherwise, use Clerk to require authentication
  return (
    <ClerkProvider {...pageProps}>
      {isPublicPage ? (
        <Component {...pageProps} />
      ) : (
        <>
          <SignedIn>
            <Component {...pageProps} />
          </SignedIn>
          <SignedOut>
            <RedirectToSignIn />
          </SignedOut>
        </>
      )}
    </ClerkProvider>
  );
}

export default MyApp;
```

</Tab>
</Tabs>
</Tab>

</Tabs>

## Next Steps

Now you have an application integrated with Clerk you will want to read the following documentation:

- Server-side APIs
- Client side helpers
- Alternative Backends